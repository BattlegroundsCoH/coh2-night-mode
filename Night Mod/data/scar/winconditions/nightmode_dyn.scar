import("ScarUtil.scar");

function NM_HookNightMode()

    -- list of blueprints to add new flare ability to
    nm_blueprintlist = {
        ["mortar_team_81mm_mp"] = BP_GetAbilityBlueprint("mortar_fire_flares_ability_mp"),
    };
    
    -- List of abilities to remove from game
    nm_hidelist = {
        BP_GetAbilityBlueprint("mortar_fire_flares_ability_mp");
    };

    -- Players to keep track of
    nm_players = {};

    -- For all players
    for i = 1, World_GetPlayerCount() do
        
        -- Get player pointer
        local player = World_GetPlayerAt(i);

        -- Remove all abilities
        for j = 1, #nm_hidelist do
            Player_SetAbilityAvailability(player, nm_hidelist[j], ITEM_REMOVED);
        end

        -- 'hook' player
        NM_HookPlayer(player);

    end

end

function NM_HookPlayer(player)
    local pid = Player_GetID(player);
    nm_players[pid] = {
        nm_player = player,
        player_group = SGroup_CreateIfNotFound("nm_p" ..pid),
    };
    if not Rule_Exists(NM_CheckPlayers) then
        Rule_AddInterval(NM_CheckPlayers, 0.15);
    end
end

function NM_CheckPlayers()
    for k, v in pairs(nm_players) do
        local sg_temp = Player_GetSquads( v.nm_player );
        SGroup_RemoveGroup(sg_temp, v.player_group);
        if (SGroup_Count(sg_temp) > 0) then
            SGroup_ForEach( sg_temp, NM_SquadSpawned ); 
            SGroup_AddGroup(v.player_group, sg_temp);
        end
        SGroup_Clear(sg_temp);
    end
end

function NM_SquadSpawned(sgroupid, itemindex, squadID)
    local abp = nm_blueprintlist[BP_GetName(Squad_GetBlueprint(squadID))];
    if (abp ~= nil ) then
        Squad_AddAbility(squadID, abp); 
    end
end
